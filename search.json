[
  {
    "objectID": "football-R6-example/index.html",
    "href": "football-R6-example/index.html",
    "title": "Football (soccer) example of object-oriented programming in R6",
    "section": "",
    "text": "R6 provides the sort of object-oriented programming capabilities that closely resemble the class system in Python or Julia and, to a lesser extent, Java, C++, and other compiled languages that natively support object-oriented programming.\nThis football/soccer example is intended as a gentle, fun introduction to object-oriented programming in R using the R6 library. Beginners will learn the basic concepts of object-oriented programming, including what a class is and how to use it to represent the state, behaviors, capacities, and susceptibilities of real-world entities: here we model soccer players, their teams, and soccer match gameplay.\nAfter the demonstration the reader can get more practice with R6 and classes by following the exercises below. These prompt the reader to expand model football gameplay by having players get penalties, making the penalties matter for the final score, and inventing their own classes to represent some other ecological process like forest systems in a watershed.\nFollow the demonstration below and study the code in the files below to learn how object-oriented programming is used to represent entities in the world and their behaviors."
  },
  {
    "objectID": "football-R6-example/index.html#project-structure",
    "href": "football-R6-example/index.html#project-structure",
    "title": "Football (soccer) example of object-oriented programming in R6",
    "section": "Project structure",
    "text": "Project structure\nWe load and use R code contained in the R/ directory of this example project. There we have the following files:\n\nR/footballer.R – defines the Footballer class, i.e., soccer player\nR/team.R – defines the Team class, which “contains” players.\nR/play_match.R – defines the play_match(team1, team2) function.\n\nIt’s common to separate the R code that defines each class into separate files, and separate any functions that relate to one type or the other, or functions that use multiple types defined across disparate files."
  },
  {
    "objectID": "football-R6-example/index.html#football-example",
    "href": "football-R6-example/index.html#football-example",
    "title": "Football (soccer) example of object-oriented programming in R6",
    "section": "Football example",
    "text": "Football example\nWe load code in R using the source command, which we’ll use now to load the code in the listed files. In each of the following blocks we load one of the files, then use some code from there to demonstrate it’s working. Following these three blocks is an example of a three-game series between two teams, the Whales and the Squirrels.\n\nsource(\"R/footballer.R\")\n\nfballer &lt;- Footballer$new(\n  speed = 15, name = \"Matt Turner\", \n  accuracy = 0.2, market_value = 1e6, \n  aggressiveness = 0.5, \n  team = \"FC Bayern Munich\"\n)\n\nprint(fballer$team)\n\n[1] \"FC Bayern Munich\"\n\n# Change attributes, e.g., if I've been practicing:\nfballer$accuracy &lt;- 0.3\n\n# We can also create anonymous players with default attributes like so:\nfballer_default &lt;- Footballer$new()\n\n\nsource(\"R/team.R\")\n\n# Create a team with two anonymous players.\nteam &lt;- Team$new(name = \"Bay FC\", \n                 players = list(Footballer$new(),\n                                Footballer$new()))\n\n\nsource(\"R/play_match.R\")\n# Have the team defined above play a scrimmage amongst themselves.\nplay_match(team, team)\n\nBay FC wins!!!\nBay FC :  1     Bay FC :  2 \n\n\n\nWhales vs. Squirrels\nInitialize two teams, Whales and Squirrels, each with two players. All players have identical default attributes.\n\nwhales &lt;- Team$new(\n  name = \"Whales\", \n  players = c(Footballer$new(), Footballer$new())\n)\nsquirrels &lt;- Team$new(\n  name = \"Squirrels\", \n  players = c(Footballer$new(), Footballer$new())\n)\n\n# Play three matches.\nplay_match(whales, squirrels)\n\nSquirrels wins!!!\nWhales :  3     Squirrels :  6 \n\nplay_match(squirrels, whales)\n\nWhales wins!!!\nSquirrels :  0     Whales :  4 \n\nplay_match(squirrels, whales)\n\nSquirrels wins!!!\nSquirrels :  4     Whales :  2 \n\n# Print how many games each time won.\ncat(\"\\nAfter three games...\", \"\\nThe Whales have won\", \n    whales$wins, \"games and the Squirrels have won\", squirrels$wins)\n\n\nAfter three games... \nThe Whales have won 1 games and the Squirrels have won 2\n\n\nWhen modeling social behavior in professional contexts, our closing paragraphs always include a meditation about the limitations of our model. In one sense it’s by design that our model assumptions do not exactly match the real world: the goals of our science is not realism but rigor. However, alternative, potentially equally justifiable, assumptions about social behavior may lead to different model outcomes. This exercise often identifies opportunities for future research that more thoroughly tests different combinations of assumptions that are empirically and practically important.\nIn our toy example of a football match, where we created our own software representations of teams and players, we made serious simplifications, but nonetheless could observe outcomes that somewhat resembled the real world: the teams won, lost, and tied, and we tracked their records over a three-game series.\nWe left out features of gameplay and personnel management that could be interesting to include in future iterations of the model. We did not include penalties. We did not differentiate shots on goal versus errant shots."
  },
  {
    "objectID": "football-R6-example/index.html#exercises",
    "href": "football-R6-example/index.html#exercises",
    "title": "Football (soccer) example of object-oriented programming in R6",
    "section": "Exercises",
    "text": "Exercises\n\nUpdate the code to model penalties and their consequences. Possible approaches include:\n\n\nIterate through all agents to see if they get penalties like with scoring.\nPossible consequences:\n\nA player from the opposing team gets a penalty kick\nThe player gets removed from contributing to the game\n\n\n\nAdd personnel management, perhaps in the form of:\n\n\nA college draft process where teams add players to their roster with fixed salary\nA Team$release_player() method to let players go, would pair with $sign_player()\nA function for teams to trade players, e.g., trade(team1, player1, team2, player2)\n\n\nAdd a Season class to schedule and run matches (i.e., with play_match), track and summarise standings, etc.\nA similar Tournament class or function to represent elimination-style tournaments.\nCreate an agent-based analysis of an ecological system, e.g., a watershed, its forests, and trees in the forest. The various spatial scales provide a natural class hierarchy: a watershed contains several forests, each of which contain several trees. The watershed’s state, e.g., rainfall, temperature, snow cover, etc., affects and is affected by the individual trees. These effects could be mediated by forest-level variables like tree density and species distribution. Grimm et al. (2005), for example, review some real-world agent-based models of European beech forests."
  },
  {
    "objectID": "groundwater-cooperation/index.html",
    "href": "groundwater-cooperation/index.html",
    "title": "Groundwater conservation cooperation",
    "section": "",
    "text": "In cooperation, payoffs are maximized"
  },
  {
    "objectID": "turner-etal-2023-philtransb/index.html",
    "href": "turner-etal-2023-philtransb/index.html",
    "title": "Prominent minority groups and transitive majority groups promote diffusion of adaptations",
    "section": "",
    "text": "Communities most affected by climate change deserve to be included in promoting sustainable adaptive behavior. In the South Pacific Island nations, Indigenous peoples may be a minority in terms of population size, but they could have a great impact on climate change adaptation. Indigenous peoples in a place have been adapting to a changing climate for possibly thousands of years.\nCommunities tend to have distinguishable groups if you look close enough. If this group structure does not affect the diffusion of adaptations, we would probably leave it out to focus on other more significant factors. However, the South Pacific Island case presents an important example of when it is important to include this group structure.\nGroup structure, in the South Pacific Islands case and in general, defined by the size of each group and how frequently groups interact with others from within their own group or between groups. These frequencies are set by the homophily of each group, which measures how much more frequent within-group versus between-group interactions are. Homophily arises due to personal choice, called choice homophily, or involuntarily due to circumstance, called induced homophily (Kossinets and Watts 2009). If you like a certain type of food, and you go to a restaurant that serves that food, your preference for that food leads you to encounter others with similar taste, an instance of choice homophily.\nFor some demographic group divisions, such as socio-economic status and race, homophily is heavily induced by, for example, historical legal and other obstacles to home ownership and other economic opportunity that led to economically and racially segregated neighborhoods, even after “segregation” became illegal. In these cases, induced homophily would dominate, say, in explaining why certain people of certain races tend to be geographically co-located, i.e., geographically assorted, since we can assume that for most people this was not a conscious choice.\nIn the models in this example we do not distinguish between types of homophily. They are important to distinguish when we go to interpret our models in real-world situations. Interpreting results like this can help guide real-world measurements of homophily by guiding researcher intuition for which measurements may the most significant.\nIn 2023 some colleagues and I developed an agent-based model of adaptation diffusion in a model population composed of a minority group and a majority group and analyzed how the asymmetric homophily of each group affected the diffusion of a model adaptation. Homophily is the degree to which We found that diffusion could be promoted by harnessing minority knowledge of adaptive behaviors at the outset of some hypothetical intervention, while majority groups could support adaptation by rapid spread in tight-knit communities (Turner et al. 2023).\nThis is just one of many possible formulations of a model of adaptation diffusion in homophilous networks. Here I demonstrate adaptation diffusion modeling with homophily network models in a somewhat simplified form, which we can call structured mixing with symmetric homophily. Structured mixing does not use a social network. Instead, one agent is selected at random from one group or the other. Agents select a group at random to learn from, weighted by the symmetric homophily, i.e., the global homophily, identical for each group:\n\\[\n\\Pr(\\text{Agent learns within group}) = \\frac{1 + h}{2}\n\\]\nThe probability the agent learns from an outgroup is just the complement of this. In this setup there is only one outgroup.\n\nModel setup\nThe main complication in using homophily-structured mixing is that one must have a way to rapidly look up who is in what group in order to sample interaction partners. One complication that is shared with alternative implementations is setting up who in which group will start with the adaptive behavior.\nTo take care of the first complication, we leverage socmod::LearningStrategy, the class that encapsulates the three functions that define how learning works: partner_selection, iteration, and model_step functions, which comprise the main iteration loop when run_trial is used to simulate model dynamics. Here is how we define the structured mixing learning strategy, first defining the partner selection function where homophilic, success-biased partner selection takes place:\n\n# Define partner selection for structured mixing.\nstructmix_successbiased_partner_selection &lt;- function(focal_agent, model) {\n  # Extract focal agent's group.\n  group &lt;- focal_agent$get_attribute(\"Group\")\n  # Get homophily attribute from the focal agent.\n  h &lt;- model$get_parameter(\"homophily\")\n  \n  # Use group lookup table to get either in-group or \n  # out-group prospective teachers.\n  group_lookup &lt;- model$get_parameter(\"group_lookup\")\n  group_names &lt;- names(group_lookup)\n\n  # Prospective teachers stored as vector; from ingroup (if) \n  # or an outgroup (else)\n  prospective_teachers &lt;- \n    purrr::list_c(ifelse(\n      sample_ingroup(h), \n      group_lookup[group], \n      group_lookup[setdiff(group_names, group)]\n    ))\n  \n  # Select an agent from the prospective teachers weighted by fitness\n  prob_weights &lt;- purrr::map_vec(\n    prospective_teachers, \n    \\(pt) pt$get_fitness()\n  )\n  return (sample(prospective_teachers, 1, prob = prob_weights)[[1]])\n}\n\n# Use our custom structured mixing function above to define the learning\n# strategy for use as the `learning_strategy` for this model's `ModelParameters`.\nstructmix_successbiased_strategy &lt;- socmod::LearningStrategy$new(\n  partner_selection = structmix_successbiased_partner_selection,\n  interaction = socmod::success_bias_interact,\n  model_step = socmod::iterate_learning_model,\n  label = \"Structured mixing, success-biased\"\n)\n\nIn the above snippet, sample_ingroup is a function that returns T with probability 0.5*(1 + homophily) (and F with the complementary probability, 0.5(1 - homophily)). This function is included of the script turner-etal-2023-philtransb/model.R, which we source below. The snippets above and below are not live in this example.\nWe now use this partner selection routine in our definition of the full model, pasted below. In the function definition we use the\n\nmake_minmaj_structmix &lt;- function(n_agents = 100, \n                                  minority_fraction = 0.05,\n                                  homophily = c(0.0), \n                                  start_group = \"Minority\",\n                                  social_learning_strategy = \n                                    structmix_successbiased_strategy,\n                                  adaptive_fitness = 1.4, \n                                  legacy_fitness = 1.0) {\n  \n  # Set up agents here!\n  n_minority &lt;- round(n_agents * minority_fraction)\n  n_majority &lt;- n_agents - n_minority\n  \n  agents_groups &lt;- c(rep(\"Minority\", n_minority), rep(\"Majority\", n_majority))\n  assertthat::are_equal(length(agents_groups), n_agents)\n  \n  agents &lt;- purrr::imap(\n    agents_groups, \\(group, a_idx) {\n      a &lt;- socmod::Agent$new(\n        id = a_idx, \n        name = paste0(\"a\", a_idx), \n        behavior = \"Legacy\", \n        fitness = legacy_fitness\n      )\n\n      # Currently this returns nothing, so need to set after creation.\n      a$set_attribute(\"Group\", group)\n      \n      return (a)\n    }\n  )\n  \n  group_lookup &lt;- make_group_lookup(agents)\n  assertthat::are_equal(group_lookup$Minority, n_minority)\n  assertthat::are_equal(group_lookup$Majority, n_majority)\n  \n  # Initialize one or two agents with the adaptive behavior.\n  if (start_group == \"Both\") {\n    \n    min_seed &lt;- sample(group_lookup$Minority, 1)[[1]]\n    maj_seed &lt;- sample(group_lookup$Majority, 1)[[1]]\n    \n    min_seed$set_behavior(\"Adaptive\")\n    maj_seed$set_behavior(\"Adaptive\")\n    min_seed$set_fitness(adaptive_fitness)\n    maj_seed$set_fitness(adaptive_fitness)\n    \n  } else if (start_group %in% c(\"Minority\", \"Majority\")) {\n    \n    seed &lt;- sample(group_lookup[[start_group]], 1)[[1]]\n    seed$set_behavior(\"Adaptive\")\n    seed$set_fitness(adaptive_fitness)\n    \n  } else {\n    \n    stop(\"start_group must be 'Minority', 'Majority', or 'Both'\")\n  }\n  \n  abm &lt;- socmod::make_abm(\n    model_parameters = socmod::make_model_parameters(\n      learning_strategy = social_learning_strategy,\n      graph = igraph::make_empty_graph(n_agents),\n      n_agents = n_agents,\n      homophily = homophily,\n      start_group = start_group,\n      adaptive_fitness = adaptive_fitness,\n      legacy_fitness = legacy_fitness,\n      group_lookup = group_lookup\n    ),\n    agents = agents\n  )\n\n  return (abm)\n}\n\n\nsource(\"model.R\")\n\nabm &lt;- make_minmaj_structmix(adaptive_fitness = 1.2, homophily = 0.5)\n\ntrial &lt;- socmod::run_trial(abm, stop = socmod::fixated)\n\nsocmod::plot_adoption(trial, tracked_behaviors = c(\"Legacy\", \"Adaptive\"))\n\n\n\n\n\n\n\n\nThis plots adoption for the whole population. It would be good to additional see adoption by group. We need a bit more customization to plot this:\n\nlibrary(magrittr)\ngroup_prevalence &lt;- function(trial, tracked_behaviors = c(\"Legacy\", \"Adaptive\")) {\n  \n  n_agents &lt;- trial$model$get_parameters()$n_agents\n  \n  groups &lt;- purrr::map_vec(trial$model$agents, ~ .x$get_attribute(\"Group\"))\n  unique_groups &lt;- unique(groups)\n  group_counts &lt;- as.list(table(groups))\n  \n  ret &lt;-\n    trial$get_observations() %&gt;% \n      dplyr::mutate(\n        \n        Group = \n          factor(\n            purrr::map_vec(\n              agent, \n              \\(aname) trial$model$get_agent(aname)$get_attribute(\"Group\")\n            ),\n            unique_groups\n          ),\n        \n        Behavior = \n          factor(Behavior, tracked_behaviors)\n      ) %&gt;%\n      dplyr::group_by(t, Group, Behavior) %&gt;%\n      dplyr::summarise(Count = dplyr::n(), .groups = \"drop\")\n  \n  # Not the prettiest, but it will do to add group-level prevalences. Other\n  # approaches didn't pan out.\n  # \n  # Initialize a prevalence column then set according values.\n  ret$Prevalence &lt;- 0.0\n  ret[ret$Group == \"Majority\", ]$Prevalence &lt;- ret[ret$Group == \"Majority\", ]$Count / group_counts$Majority\n  ret[ret$Group == \"Minority\", ]$Prevalence &lt;- ret[ret$Group == \"Minority\", ]$Count / group_counts$Minority\n  \n  ret &lt;- tidyr::complete(ret, t, Group, Behavior, \n                         fill = list(Count = 0, Prevalence = 0))\n  \n  return (ret)\n}\n\ngprev &lt;- group_prevalence(trial)\n\nplot_by_group_prevalence &lt;- function(trial) {\n  gprev &lt;- group_prevalence(trial)\n  p &lt;- \n    dplyr::filter(gprev, Behavior == \"Adaptive\") %&gt;% \n      ggplot(aes(x = t, y = Prevalence, color = Group)) + \n        geom_line(linewidth = 1) + \n        xlab(\"Step\") +\n        ylab(\"Prevalence (within group)\") +\n        theme_classic(base_size = 12) + \n        scale_color_brewer(palette = \"Set1\")\n  \n  return (p)\n}\n\n\n\nComputational experiment\n\nabm &lt;- make_minmaj_structmix(adaptive_fitness = 1.2, homophily = 0.5)\n\ntrial &lt;- socmod::run_trial(abm, stop = socmod::fixated)\n\np &lt;- plot_by_group_prevalence(trial)\nprint(p)\n\n\n\n\n\n\n\n\n\n# make_minmaj_structmix_byrow &lt;- function(parameter_list) {\n#    \n# }\n# \n# trials &lt;- socmod::run_trials(\n#   model_generator = make_minmaj_structmix,\n#   n_trials_per_param = 2,\n#   stop = 5,\n#   adaptive_fitness = 1.2,\n#   homophily = c(-0.5, 0.0, 0.5)\n# )\n# \n# print(trials)\n\n\n\n\n\n\nReferences\n\nKossinets, Gueorgi, and Duncan J. Watts. 2009. “Origins of homophily in an evolving social network.” American Journal of Sociology 115 (2): 405–50. https://doi.org/10.1086/599247.\n\n\nTurner, Matthew A., Alyson L. Singleton, Mallory J. Harris, Ian Harryman, Cesar Augusto Lopez, Ronan Forde Arthur, Caroline Muraida, and James Holland Jones. 2023. “Minority-group incubators and majority-group reservoirs support the diffusion of climate change adaptations.” Philosophical Transactions of the Royal Society B: Biological Sciences 378 (1889). https://doi.org/10.1098/rstb.2022.0401."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "socmod examples",
    "section": "",
    "text": "Examples demonstrating how to use the socmod library for modeling social behavior. The library could possibly be used for computational modeling in other fields like ecology and perhaps biology more broadly.\n\n\n\nFootball/soccer example that illustrates how to use the R6 library for object-oriented programming. Understanding object-oriented programming concepts will help design agent-based models of social behavior, and is a key component in the design of socmod.\nDiffusion in minority-majority populations where simulated adaptation prevalence can be boosted by harnessing prominent minority groups and cohesive majorities (Turner et al. 2023)\n\n\n\n\nSimple diffusion of adaptive behaviors with different learning strategies\nMedici solar panel business opportunity\nA simplified version of Turner et al 2023"
  },
  {
    "objectID": "index.html#index",
    "href": "index.html#index",
    "title": "socmod examples",
    "section": "",
    "text": "Football/soccer example that illustrates how to use the R6 library for object-oriented programming. Understanding object-oriented programming concepts will help design agent-based models of social behavior, and is a key component in the design of socmod.\nDiffusion in minority-majority populations where simulated adaptation prevalence can be boosted by harnessing prominent minority groups and cohesive majorities (Turner et al. 2023)\n\n\n\n\nSimple diffusion of adaptive behaviors with different learning strategies\nMedici solar panel business opportunity\nA simplified version of Turner et al 2023"
  }
]